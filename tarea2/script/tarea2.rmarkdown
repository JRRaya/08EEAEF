---
title: "Análisis espacial de puntos"
format:
  html:
    code-fold: true
    toc: true
    number-sections: true
    embed-resources: true
    self-contained-math: true
knitr:
  opts_knit:
    root.dir: ".."
---

# Carga de datos y paquetes


```{r}
#| label: setup
#| echo: false

# 1. Carga de paquetes y limpieza de entorno
# 1.1. Limpiamos la RAM
rm(list = ls(all.names = TRUE))
pacman::p_unload(pacman::p_loaded(), character.only = TRUE)
gc(full = TRUE)

# 1.2. Cargamos las librerías a emplear
pacman::p_load(sf, terra, tidyverse, data.table, readxl, spatstat, onpoint, patchwork)

# 2. Carga de datos
lista_dfs <- setNames(
  lapply(
    excel_sheets("data/tarea2.xlsx")[2:3], # Filtramos para leer solo hojas 2 y 3
    function(x) {
      df <- readxl::read_excel("data/tarea2.xlsx", sheet = x, col_names = FALSE)
      setNames(df, c("x", "y"))
    }
  ), 
  excel_sheets("data/tarea2.xlsx")[2:3] # Filtramos también los nombres para el setNames
)
```

# Análisis univariante

```{r}
#| label: analisis-univariante

# 3. Análisis univariante
# 3.1. Definir función de análisis univariante
analisis_univariante <- function(lista, n = 999) {
  # Normalización de los nombre
  nombres <- tolower(gsub("[[:punct:]]", "_", names(lista)))
  names(lista) <- nombres
  
  # Lista de guardado
  resultados <- list()

  # Bucle de análisis univariante
  for(i in nombres) {
    # Carga de los datos de la especie
    df <- lista[[i]]

    # Contrucción del objeto 'ppp'
    x <- ppp(df$x, df$y, window = owin(range(df$x), range(df$y)))

    # Guardado directo de los resultados en la lista
    resultados[[i]] <- list(
      K = envelope(x, Kest, nsim = n, correction = "all", verbose = FALSE),
      L = envelope(x, Lest, nsim = n, correction = "all", verbose = FALSE),
      L_c = envelope(x, center_Lest, nsim = n, correction = "all", verbose = FALSE),
      G = envelope(x, pcf, nsim = n, correction = "all", verbose = FALSE),
      O = envelope(x, Oest, nsim = n, correction = "all", verbose = FALSE)
    )
  }

  # Devuleve la lista de resultados
  return(resultados)
}

# 3.2. Cálculo de resultados
resultados_univariante <- analisis_univariante(lista = lista_dfs)

# 3.3. Emplear 'onpoint::plot_quantums()' para la visualización
for(i in names(resultados_univariante)) {
  # Lista de estadísticos para la especie
  estadisticos <- resultados_univariante[[i]]

  # Iteramos sobre cada estadístico
  for(j in names(estadisticos)) {
    # Estadístico
    estadistico <- estadisticos[[j]]

    # Contruimos el gráfico
    p <- plot_quantums(
      estadistico, 
      labels = c("obs > hi)", "lo < obs < hi", "obs < lo"),
      base_size = 20,
      line_size = 1
    ) + 
      labs(title = paste("Especie:", i , "| Estadístico:", j))
    
    # Graficamos
    print(p)
  }
}
```

# Análisis bivariante


```{r}
#| label: analisis-bivariante

# 4. Análisis bivariante
# 4.1. Creamos la función de análisis bivariante
analisis_bivariante <- function(i, j, n = 999) {
  # Creación del objeto 'ppp'
  x <- ppp(
    x = c(i$x, j$x),
    y = c(i$y, j$y),
    window = owin(range(c(i$x, j$x)), range(c(i$y, j$y))),
    marks = factor(c(rep("1", nrow(i)), rep("2", nrow(j))))
  )

  # Cálculo de los estadísticos (combinación lineal de Eij y Eji)
  resultados <- list(
    K = envelope(x, Kcross, correction = "all", i = "1", j = "2", nsim = n, verbose = FALSE),
    L = envelope(x, Lcross, correction = "all", i = "1", j = "2", nsim = n, verbose = FALSE),
    G = envelope(x, pcfcross, correction = "all", i = "1", j = "2", nsim = n, verbose = FALSE)
  )
}

# 4.2. Cálculo de resultados
resultados_bivariante <- analisis_bivariante(i = lista_dfs$Q_ilex, j = lista_dfs$Q_faginea)

# 4.3. Representación visual de los resultados
for(i in names(resultados_bivariante)) {
  # Estadistico a graficar
  estadistico <- resultados_bivariante[[i]]
  
  # Contruimos el gráfico
  p <- plot_quantums(
    estadistico, 
    labels = c("obs > hi)", "lo < obs < hi", "obs < lo"),
    base_size = 15,
    line_size = 1
  ) + 
    labs(title = paste("Estadístico:", j))
  
  # Graficamos
  print(p)
}
```
